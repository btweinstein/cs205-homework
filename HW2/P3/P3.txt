I will list the performance for each case below.

#### Default Serial ####

1074.69 Million Complex FMAs in 3.04275608063 seconds
353.196613045 million Complex FMAs / second

##### prange alone ####

prange with one thread:
1074.691142 Million Complex FMAs in 3.09189105034 seconds
347.583768155 million Complex FMAs / second

prange with two threads:
1074.691142 Million Complex FMAs in 1.547093153 seconds
694.651863668 million Complex FMAs / second

prange with four threads:
1074.691142 Million Complex FMAs in 0.777901887894 seconds,
1381.5253038 million Complex FMAs / second

prange with 12 threads (max):
1074.691142 Million Complex FMAs in 0.296374082565 seconds
3626.13064104 million Complex FMAs / second


#### prange and AVX ####

prange with one thread:
1075.239963 Million Complex FMAs in 0.948863983154 seconds
1133.18661272 million Complex FMAs / second

prange with two threads:
1075.239963 Million Complex FMAs in 0.752876996994 seconds
1428.17481115 million Complex FMAs / second

prange with four threads:
1075.239963 Million Complex FMAs in 0.476514101028 seconds
2256.47039758 million Complex FMAs / second

prange with 12 threads (max):
1075.239963 Million Complex FMAs in 0.317208051682 seconds
3389.69946475 million Complex FMAs / second

#TODO: Figure out why I have the slight difference in FMA totals

############ Summary ##########################

See the plot "timing_vs_technique_scaled.png". For 1, 2, and 4 threads we see behavior
we expect. For 1 thread vs. serial code, the threaded code runs slightly slower
due to the overhead of threading. When we we add two threads, we get a speedup
of approximately 2. When we have 4 threads, we get a speedup of approximately 4. Interestingly,
when we use 12 threads (the number of effective cores my computer has), we find a speedup of
about 10, indicating that the execution speed does not scale perfectly with the number of cores. This could
be due to a bottleneck in the code (i.e. with an infinite number of cores, we would only see a speedup of about
10x), or could represent the cost associated with creating and maintaining additional parallel jobs.

When we add AVX and threading, the results are more unexpected. Naively, since we operate on 8 numbers at once,
we would expect the speed with N threads relative to serial code to be roughly 8N. Instead, with
1 thread, we speedup of about 3x, 2 threads ~ 4x, 4 threads ~6.5x, and 12 threads ~ 10x. The reason for this imperfect
scaling is likely that when we are operating on 8 numbers at once, we do not stop operating on them until *all*
pixels have finished. Hence, the speedup in each set of 8 is limited by the slowest pixel.

Interestingly, the speedup for 12 threads with and without AVX is about the same.
This hints that we have "saturated" the code with parallel processors; adding additional cores or AVX techniques will
not necessarily help speed up the code.