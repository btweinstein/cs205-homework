>>Compare performance with 4 and with 1 thread (i.e., serial performance), and
discuss the reasons for any performance difference.

With one thread, we get roughly 12 fps. With 4 threads, we get roughly
16 fps. This is a very small speedup; we naively expect that N cores
should speed us up N times. The overhead must be gigantic here; we are likely doing expensive operations
at inappropriate times as we have not implemented locks. Qualitatively, the behavior of the simulation
still looks correct, however.

>>Spatial Decomposition

Spatial decomposition *dramatically* increases the FPS of our simulation. With one thread, we get
about 700 fps, while with four threads we find something like 800-900fps. Adding additional threads
does not seem to have a gigantic impact, surprisingly. It is not surprising that we see large
speedups here, as our algorithm changed from O(N^2) to O(N) when N=10^4.

>>Spatially Coherent Sorting

I use Morton ordering, borrowing from a package written by the Lawrence Livermore National Lab
(see morton.py).

With one thread, we average about 600fps which is not fantastic relative to the old performance.
With four threads, we average about 800-900 fps. We do not see any significant speedups due to this
technique, unfortunately. Perhaps the overhead of sorting is too high.

#TODO: Figure out why this is

>> Locking

With locking, one thread, and our previous improvements we average about 500 fps. With locking and
four threads, we average about 700 fps. Locking likely slows done the code slightly as
each thread cannot enter the collision code simultaneously for a given particle; if that particle is
colliding with something else, another thread cannot collide it with another particle. This makes sense
physically; collisions should be handled individually and should not be interrupted by other threads.
Locking consequently slightly decreases speed but makes our simulation much more realistic.